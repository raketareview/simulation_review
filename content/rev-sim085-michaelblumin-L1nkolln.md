https://github.com/L1nkolln/Simulation_2DD  
[Michael Blumin]

Есть много над чем поработать.

## НЕДОСТАТКИ РЕАЛИЗАЦИИ

1. Изменение слайдов карты происходит так быстро, что не успеваешь рассмотреть, что там происходит.

2. Общая визуальная эстетика на низком уровне. 

И дело даже не в том, что карта распечатывается буквами- ширину ячейки стоило бы сделать шире, например в три символа. 
Тогда квадратная карта будет выглядеть действительно квадратной.  
Сейчас карта размером 10x10 при распечатке не выглядит квадратной
```
=== Ход 1 ===
.........H
..R.......
.....GR...
.H.G..T...
.P..R..G..
..G..T....
...T..G.HP
....GT.R..
..........
H.........
```

Реализации с емоджи смотрятся все равно лучше, чем с буквами, вот например
```
-------- Turn: 5 ---------
⛰️🟫🌿🟫🟫🟫🟫🟫🟫🟫🟫🟫
🟫🟫🟫🐺🟫🟫🟫🟫🟫⛰️🟫🟫
🟫🟫🦌🟫🟫🟫🟫🟫🟫🟫🟫🟫
🟫🟫🟫🟫🟫🟫🟫🟫🟫🟫🟫🟫
🌿🟫🦌🟫🟫🟫🟫🟫🟫🟫🟫🟫
🟫🟫🟫🟫🟫🦌🟫🟫🟫🟫🟫🟫
🟫🟫🟫🟫🟫🌳🟫🟫🟫🟫🟫🟫
🟫🟫🟫🌳🟫🌳🟫🟫⛰️🟫🟫🟫
🟫🟫🟫🟫🟫🟫🟫🟫🟫🟫🟫🟫
🟫🟫⛰️🟫🟫🟫🟫🟫🟫🟫🟫🟫
🟫🟫🟫🟫🟫🟫🟫🟫🟫🟫🟫⛰️
🟫🌿🟫🟫🟫🟫🟫🟫🟫🌳⛰️🟫
```

## ХОРОШО

+ 👍 Работает 

## ЗАМЕЧАНИЯ

**1. Нейминг**

- Названия пакетов нужно писать стилем lower_snake
```
Game
Entity

//ПРАВИЛЬНО:
game
entity
```

- Если в проекте есть класс `World` то все переменные с именем, включающим это название, должны быть экземплярами этого класса
```
public class World {
  private Map<Position, Entity> world;
  //...
}

//ПРАВИЛЬНО:
public class World {
  private Map<Position, Entity> entities; //или positionWithEntities;
  //...
}
```

- Название обманывает. Метод не инициализирует действия, метод заселяет создает экземпляр карты и заселяет в нее существ на фиксированные позиции
```
public static World initAction()
```

*Oracle Java code conventions, part."Naming conventions"*  
*Мартин, "Чистый код", гл.2*  
*Ютуб, Немчинский "Как называть переменные, методы и классы?"*  

**2. Избыточно.** При объявлении полей класса, если им не заданы значения, то они устанавливаются значениями по умолчанию. 
Для int это будет 0
```
private int tickCounter = 0;

//ПРАВИЛЬНО:
private int tickCounter;  // = 0
```
В других языках, например в `Си++`, действительно при объявлении переменной всегда нужно устанавливать ей явное значение.

**3. Нарушение конвенции кода.** В любой ситуации выделяй тело блока скобочками, даже если тело состоит из одной строки. 
Исключение- метод equals(), там можно после if не выделять блоки скобочками
```
if (visited.contains(neighbor)) continue;
if (e instanceof Rock || e instanceof Tree || e instanceof Creature) continue;

//ПРАВИЛЬНО:
if (visited.contains(neighbor)) {
  continue;
}
if (e instanceof Rock || e instanceof Tree || e instanceof Creature)  {
  continue;
}
```

**4. Закомментированный код это антипаттерн "Лодочный якорь"**

Закомментированный код это всегда мусор- после того, как его закоментировали, он никогда больше не понадобится.
`Predator` и некоторые другие классы наполовину состоят из лодочного якоря.  
Не превращай код в мусорку. Если что-то хочешь сохранить на память, сделай коммит в гите с соответствующим комментарием.  
Правильное использование комментариев- *"Чистый код", гл.4*

**5. Сразу кастуй**
```
if (entity instanceof Creature) {
  ((Creature) entity).makeMove(this);
}

//ПРАВИЛЬНО:
if (entity instanceof Creature creature) {
  creature.makeMove(this);
}
```

**6. Если нужно печатать или создавать строку** с более, чем одним подстановочным значением или значение вставляется внутрь сообщения, используй форматированный вывод- тогда сразу будет виден весь шаблон
```
System.out.println("=== Ход " + turn + " ===");

//ПРАВИЛЬНО:
System.out.printf("=== Ход %d === \n", turn);
```

**7. class Position**

- В принципе, координатный класс можно позиционировать как структуру и сделать два его поля публичными. 
Но тогда в нем не должно быть геттеров. 
Если есть геттеры- поля не должны быть публичными
```
public class Position {
  public final int x;
  public final int y;
  
  //...
  public Integer getX() {...}
  public Integer getY() {...}
}
```

- Здесь поле- примитив. Почему геттер поля возвращает не примитив, а обертку?
```
public final int x;

public Integer getX() {
  return x;
}

//ПРАВИЛЬНО:
public int getX() {
  return x;
}
```

- Нарушение SRP. 

Единая ответственность координаты- хранить данные для идентификации точки в двумерном пространстве. 
В данном случае- хранить и выдавать значения x и y.
Для выполнения этой ответственности координате не нужен метод, который определяет соседнюю координату
```
public boolean isNeighbour(Position position)
```
Класс Координата может отлично жить без этого метода. 
Определи тот класс, который не может жить без этого метода и перенеси его туда.

- Избыточно. Тут всего два примитива
```
public boolean equals(Object o) {
  //...
  return Objects.equals(x, position.x) && Objects.equals(y, position.y);
}

//ПРАВИЛЬНО:
public boolean equals(Object o) {
  //...
  return this.x == position.x && this.y == position.y;
}
```

**8. class World**

- Божественный класс. Не имеет одной ответственности, у него их больше десятка.

- Нарушение SRP, методы чужих ответственностей. 

Карта должна только хранить существа и обеспечить базовые операции с ними: вставить, выдать одно существо и список всех хранимых существ, удалить.
Если какой-то метод не нужен для обеспечения этого функционала, значит он не принадлежит к ответственности карты, а принадлежит к чужой ответственности.

Здесь методы чужих ответственностей: от начального заселения карты существами, до вызова хода существами вместо предусмотренного ТЗ соответствующего Action'а и распечатки карты.

Наверное, для проекта в целом полезно иметь метод, который распечатывает карту. 
Но этот процесс не имеет никакого отношения к единой ответственности карты- хранению существ в себе.  

Методы чужих ответственностей должны находиться в тех классах, в интересах которых они работают.
Если один и тот же метод используют разные классы, то метод нужно вынести в отдельный класс, например, BoardUtils.

- Никогда не возвращай null
```
private Map<Position, Entity> world;

public Entity getEntity(Position pos) {
  return world.get(pos);  //может вернуть null
}

public Position findClosestHerbivore(Position start, Position goal) {
  //...
  return null;
}
```
Возврат null повышает риск возникновения NullPointerException в программе.  
*Мартин, "Чистый код", гл.7.7-8*  
*Ютуб, Немчинский "Почему нельзя возвращать NULL?"*

- Нарушение инкапсуляции, класс предоставляет клиентскому коду подробности внутреннего устройства и доступ к нему
```
private Map<Position, Entity> world;

public Map<Position, Entity> getWorld() {
  return world;
}
```
В данный момент клиентский код может выполнять любые операции с HashMap Карты напрямую, игнорируя допустимые картой способы. 
Например так
```
Карта карта = new Карта(100, 100);
<заселить карту существами>
карта.getWorld().clear(); //геноцид- удаление из карты всех существ, минуя дозволенные картой механизмы
```
Из-за этого класс является гибридом со всеми вытекающими последствиями: *"Чистый код", гл.6* 

- Нарушение SRP, чужая ответственность, зависимость модели от представления.
Модель(а это модель) не должна ничего печатать в консоль
```
public void render() {
  //печатает карту в консоль  
}
```
Иначе модель перестает быть универсальной и становится заточенной под конкретную среду и конкретное представление себя в этой среде- в данном случае, консоль.
В других средах(напр. Андроид) модель нельзя будет использовать- там этот класс-модель просто не скомпилируется из-за команды печати в консоль. 
Другое представление для модели(напр. если одну и ту же модель нужно в программе показывать по-разному) нельзя будет сделать, или придется делать через костыль.

Распечатка карты должна быть в отдельном классе, напремер `Renderer`.

- Нарушение SRP, карта не должна быть одновременно фабрикой карты
```
public static World initAction() {
  World world = new World(10, 10);

  world.addEntity(new Grass(new Position(3, 3)));
    world.addEntity(new Grass(new Position(6, 6)));
    world.addEntity(new Grass(new Position(4, 7)));
    //еще миллион строк
    return world;
  }
```
Да, карта могла бы содержать в себе фабричный метод, который создавал бы карту, если бы создание экземпляра карты требовало какой-то сложной логики. 
Но этот фабричный метод, расположеный в самой Карте, все равно не имел бы права заселять карту существами.

- При всех операциях с участием координаты(добавить, выдать, удалить и т.д.), нужно проверять координату на корректность. 
Если координата некорректна(находится вне пределов карты), нужно бросать исключение
```
public Entity removeEntity(Position pos) {
  return world.remove(pos);  <-- Что если сюда придет pos с координатами (1000000, -1000000)?
}
```

- Разделяй команды и запросы.  
Этот метод должен или выполнить действие, или ответить на запрос. Но не то и другое вместе
```
public boolean addEntity(Entity entity) {
  Position pos = entity.getPosition();
  if (!isInZone(pos) || world.containsKey(pos)) {
    return false;  <-- ОТВЕЧАЕТ НА ЗАПРОС
  }
  world.put(pos, entity);  <-- ВЫПОЛНЯЕТ ДЕЙСТВИЕ
  entity.setPosition(pos);
  return true;  <-- ОТВЕЧАЕТ НА ЗАПРОС
}
```
В данном случае метод должен быть `void`, а если вставка существа по каким-то причинам не произошла, нужно бросать исключение.
*Мартин, "Чистый код", гл.3, "Разделение команд и запросов"*  

- Нарушение инкапсуляции.

Публичными должны быть только те методы, которые предусмотрены для использования клиентским кодом.  
Если к методу обращается только сам класс, в котором этот метод находится, то этот метод должен быть private или protected. 
По умолчанию любой метод нужно делать приватным и открывать его для публики только в том случае, если на это есть причина.

Здесь, например, метод `public int getTickCounter()` используется только внутри самой Карты.

❌ Класс собрал в себе все худшие практики для класса Карта.

**9. Поиск пути**

- Поиск пути сейчас находится в божественной карте. Поиск должен находиться в отдельном классе.

- Нарушение SRP. 

Поиск должен просто искать путь от точки старта до точки, соответствующей заданным условиям. 
В данном случае- до точки, в которой находится существо нужного класса.
Если поиск получает во входящие конкретный экземпляр цели, значит часть работы поиска уже выполнил кто-то другой. 
То есть, кто-то другой уже нашел цель и передал ее в поиск пути
```
public List<Position> findPath(Position start, Position goal)
```
На самом деле поиск пути должен сам искать цель и прокладывать к ней путь. Сигнатура метода для этого должна выглядеть примерно так
```
public List<Coordinates> getPatch(World world, Coordinates start, Class<? extends Entity> target) {
  //ищет путь на карте world от точки start
  //до точки, где находится существо нужного класса(напр. Grass.class)
}
```

- Нарушение DRY. Два метода, которые делают одно и то же- ищут существо определенного класса. Код методов идентичен, кроме одной строки
```
public Position findNearestGrass(Position start) {
  //миллион строк
  Entity entity = getEntity(current);
  if (entity instanceof Grass) {...}
  //миллион строк
}

public Position findNearestHerbivore(Position start) {
  //миллион строк
  Entity entity = getEntity(current);
  if (entity instanceof Herbivore) {...}
  //миллион строк
}

//ПРАВИЛЬНО:
public Position findNearest(Position start, Class<? extends Entity> target) {
  //миллион строк
  Entity entity = getEntity(current);
  if (target.isInstance(entity)) {...}
  //миллион строк
}
```

- Нарушение Low Coupling. 

В своей работе поиск не должен ничего знать про конкретные классы наследников entity- Rock, Tree и др.
```
if (e instanceof Rock || e instanceof Tree || e instanceof Creature) continue;
```
Для алгоритма поиска достаточно сравнивать класс каждого встречного существо со значением `Class<? extends Entity> target` и определять тем самым, нашли ближайшую цель или еще нет. 

- Эти неизменяемые переменные нужно вынести из метода и сделать константами, чтобы объекты с ними(а массивы это объекты), не пересоздавались каждый раз при вызове метода
```
public List<Position> getNeighbours(Position pos) {
  int[] dx = {0, 0, -1, 1};
  int[] dy = {1, -1, 0, 0};
  //...
}

//ПРАВИЛЬНО:
private final static List<Position> SHIFT_POSITIONS = List.of(new Position(0, 1), new Position(0, -1), ...);

public List<Position> getNeighbours(Position pos) {
  //...
}
```

**10. abstract class Entity**

- Содержит координату. Но координата нужна только тому существу, которое ходит. Поэтому entities должны хранить координату только начиная с уровня `Creature`.

- Нарушение SRP, зависимость модели от представления- существо хранит спрайт с собственным изображением
```
public abstract char getSymbol();
```
Модель(а это модель) не должна зависеть от представления и знать, как ее будут показывать юзеру.
Потому что в разных средах(консоль, Swing, Android) одна и та же модель может быть показана разными способами.
Спрайты всех существ должны храниться в классе, который распечатывает карту.

- Нарушение инкапсуляции. Совершение случайного хода используется только потомками этого класса. Поэтому метод должен быть protected
```
public void moveRandom(World world)
```

**11. class Herbivore**

- Магическое число: 15.

- Всегда явно указывай область видимости: private, public или protected
```
void eat(World world, Position pos)
```

**12. Action'ы, которых нет**

В ТЗ указаны Action'ы, которые должны быть в проекте. 
Здесь их нет и весь тот функционал, который по ТЗ должны реализовывать экшены, перенесен в божественный класс Карта.

Нарушать ТЗ можно, когда это улучшает архитектуру проекта. 
Отсутствие Action'ов здесь ухудшает архитектуру, поэтому сделай Action'ы так, как указано в ТЗ.

Идея состоит в том, что нужно создать семейство родственных классов, объединенных общим интерфейсом.  
Каждый из этих классов должен делать что-то свое с картой: один экшен должен заселять карту существами, другой делать ходы и т.д.  
Actions, изложенный в ТЗ, это вариант реализации паттерна Command.  

То есть экшены должны быть родственны и одинаково использоваться через полиморфизм. Примерно так
```
interface Action{
 void execute(Карта карта);
}

class ХодитьAction реализует Action {
  void execute(Карта карта) {
    //обойти всю карту
    //найти каждую креатуру
    //и дать ей пинка чтоб побежала
  }
}

class ДатьСигаретуВсемЗайцамAction реализует Action {
  void execute(Карта карта) {
    //обойти всю карту
    //найти всех зайцев и дать им по сигарете 
  }
}

List<Action> actions = List.of{new ДатьСигаретуВсемЗайцамAction(), new ХодитьAction()};
for(Action a: actions) {
  a.execute(карта);
}

/*
Результат: программа обойдет всю карту, найдет всех креатур и даст им пинка, чтобы они побежали.
А каждому зайцу предварительно даст сигарету.
*/
```

**13. Начальная расстановка существ в карте**

- Сейчас начальная расстановка существ на карте происходит в самом классе Карта, тем самым нарушая ее SRP.
Начальную расстановку существ нужно сделать как указано в ТЗ- реализовать в виде Action'a.

- Существа нужно расставлять на случайные позиции, а не на заранее назначенные. А то так неинтересно.

**14. class Simulation**

- Содержит точку входа main(). 

Точка входа должна находиться в отдельном классе. 
Задача класса, содержащего `main()` состоит только в том, чтобы сконфигурировать приложение(создать все зависимости) и запустить его.

Класс с точкой входа *здесь* должен выглядеть примерно так
```
public class Main {
  private final static int WIDTH = 10;
  private final static int HEIGHT = 10;
  
  public static void main(String[] args) {
    World world = new World(WIDTH, HEIGHT);
    Simulation simulation = new Simulation(world);
    simulation.start();
  }
}
```
*Мартин "ЧК", гл.11, "Отделение main"*

- Когда из этого класса будет вынесена точка входа, нужно будет сделать конструктор. 
Этот конструктор должен принимать необходимые зависимости, как минимум- экземпляр карты.  
Примерно так
```
public Simulation(World world) {
  this.world = world;
}
```

## ВЫВОД

Сделать Action'ы по ТЗ, разделить по ответственностям божественный класс на множество других классов.

Судя по коду, нет представления о декомпозиции классов в ООП стиле- даже предварительно проведенная Сергеем и описанная в ТЗ декомпозиция была нарушена. 
Для лучшего понимания декомпозиции ООП посмотреть ролики Сергея про шахматы. Посмотреть ролики Немчинского про SOLID.  
Мой стрим по декомпозиции [Крестики-нолики в ООП стиле](https://t.me/zhukovsd_it_chat/53243/187097)

n.85(190)  
#ревью #симуляция 