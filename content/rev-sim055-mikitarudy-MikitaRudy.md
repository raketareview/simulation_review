https://github.com/MikitaRudy/Simulation  
[Mikita Rudy]

Есть над чем поработать.

## ХОРОШО

1. Координаты существ не хранятся в самих существах(мне так больше нравится)
2. Применяются стримы

## ЗАМЕЧАНИЯ

**1. Нейминг**

- Название метода вводит в заблуждение. Метод не только печатает меню, но еще принимает команду юзера и по этой команде выполняет соответствующее действие
```
void printMenu()
```
Поэтому при чтении кода кажется, что программа только тем и занимается, что в вечном цикле распечатывает меню
```
while (true) {
  printMenu();
}
```

-Не понятно, почему этот класс назван во множественном числе, если он выполняет только одно дейсвие- заселение карты существом
```
class InitActions
```

- В пакете `tool` часть классов имеют постфикс "Tool", а часть не имеет. Неясен принцип наделения и ненаделения этим постфиксом классов в одном и том же пакете.

- Это не приветствие, это текст меню запуска симуляции
```
public static final String WELCOME = """
  Добро пожаловать в Симуляцию
  Введите:
  [1] - запустить симуляцию
  [0] - выйти из приложения
""";
```

- Избыточный контекст
```
WorldMapPrintTool.printWorldMap(...);

//ПРАВИЛЬНО:
WorldMapPrintTool.print(...);
```

*Oracle Java code conventions, part."Naming conventions"*  
*Мартин, "Чистый код", гл.2*  

**2. Нарушение DRY**, магические буквы, числа, слова. Вводи константы. А если они уже есть- пользуйся
```
public static final String WELCOME = """
      Добро пожаловать в Симуляцию
      Введите:
      [1] - запустить симуляцию
      [0] - выйти из приложения
      """;

public static final String ONE = "1";
public static final String ZERO = "0";

//ПРАВИЛЬНО:
public static final String ONE = "1";
public static final String ZERO = "0";

public static final String WELCOME = """
      Добро пожаловать в Симуляцию
      Введите:
      [%s] - запустить симуляцию
      [%s] - выйти из приложения
      """.formatted(ONE, ZERRO);

```
*Фаулер, "Рефакторинг", гл.8 п."Замена магического числа символической константой" *  
*refactoring.guru "Замена магического числа символьной константой"*  

**3. Создавай вспомогательные методы**, делай программу более простой и понятной
```
if (!visited.contains(neighbor) && isPositionAccessible(neighbor, targetType)) {...}

//ПРАВИЛЬНО:
if (isНазваниеКотороеВсеОбъясняет(/*args or empty*/)) {...}

private boolean isНазваниеКотороеВсеОбъясняет(/*args or empty*/) {
  return !visited.contains(neighbor) && isPositionAccessible(neighbor, targetType);
}
```

**4. Никогда не возвращай null**
```
public <T extends Entity> Position findNearestEntity(Position start, Class<T> targetType) {
  //...
  return null;
}
```
Возврат null повышает риск возникновения NullPointerException в программе

*Мартин, "Чистый код", гл.7.7-8*  
*Ютуб, Немчинский "Почему нельзя возвращать NULL?"*  

**5. class Constants**, класс с константами

- Класс должен быть final и иметь приватный конструктор по умолчанию.

Про особенности использования константных классов я писал тут: https://t.me/zhukovsd_it_chat/53243/176984

**6. Пакет map**, содержит классы Position и WorldMap

+ (+)Да, Позиция существует в интересах Карты, значит они должны быть вместе и желательно в одном пакете.

**7. class Position**, координата

+ (+)Нет ничего лишнего, это хорошо.
- (±)Класс может быть преобразован в рекорд без потери функционала.

**8. class WorldMap**

- Нарушение инкапсуляции, эти поля не должны быть публичными, используй геттеры
```
public final int width;
public final int height;
```

- Никогда не возвращай null
```
public Entity getEntity(Position position) {
  return entities.get(position);  //может вернуть null
}
```

- Карта должна разрешить вставить существо по координате в том случае, если координата находится в пределах ширины и высоты карты.
При этом неважно, будет эта ячейка занята или нет.
Разрешать вставлять существо на занятую ячейку или не разрешать- это ответственность не карты, а игровой логики и должна находиться в том классе, который эту логику реализует.

Например, в зависимости от алгоритма съедения зайцев волками, волк может или сразу стать на координату съедаемого зайца, то есть один ентити стает на координату с другим ентити. Или волк становится рядом с зайцем и уменьшает его жизни, пока не съест его полностью.
В любом случае, карта не должна касаться этих вопросов.

Здесь карта должна проверять только те условия, которые касаются непосредственно ее ответственности, в данном случае- находится ли координата в допустимом диапазоне
```
public void putEntity(Position position, Entity entity) {
  if (isPositionEmpty(position) && isPositionEmpty(position)) {
    entities.put(position, entity);
  }
}
```

- При всех операциях с участием координаты(добавить, выдать, удалить и т.д.), нужно проверять координату на корректность
```
public void removeEntity(Position position) {
  entities.remove(position);
}
```
Если координата некорректна(находится вне пределов карты), нужно бросать исключение.

- Метод совершения хода в карте- нарушение SRP.
Теперь можно вызвать из карты метод хода и телепортировать зайца из одного края в другой минуя все правила игровой логистики
```
Карта карта = new Карта(100, 100);
карта.putEntity(new Position(0, 0), new Заяц());
карта.moveEntity(new Position(0, 0), new Positions(99, 99));

/* class WorldMap */
public void moveEntity(Position oldPos, Position newPos) {
  if (isPositionValid(newPos) && isPositionEmpty(newPos)) {
    Entity entity = entities.get(oldPos);
    if (entity != null) {
      entities.remove(oldPos);
      entities.put(newPos, entity);
    }
  }
}
```
Должна ли карта учитывать логистику зайцев? Если да, то как? Единственно правильный ответ- карта вообще не должна иметь в себе метод телепортации.

- Нарушение SRP.
Карта должна работать со всеми хранимыми существами одинаково и не работать как-то по-особому с конкретным классом представителей и не должна даже знать по именам наследников Entity
```
public List<Creature> getAllCreatures() {...}
```

Здесь специальный метод для возврата креатур тем более не имеет смысла, потому что есть универсальный метод, через который можно получить список существ нужного класса
```
public <T extends Entity> List<T> getEntitiesByType(Class<T> type) {...}
```

+ (+)В целом класс только минимально нарушает SRP.

**9. class PathFinder**

- Нарушение SRP. Класс должен просто искать путь от точки старта до точки, соответствующей заданным условиям.
В данном случае- до точки, в которой находится существо нужного класса.
Здесь поиск принимает в себя не только начальную точку, откуда начинается поиск. Но и конечную точку поиска, что неправильно
```
public <T extends Entity> List<Position> findPath(Position start, Position end, Class<T> targetType) {...}
```
Таким образом, процесс поиска, как единая ответственность, разделен на несколько классов. Один класс осуществляет предварительный поиск и находит существо на `Position end`.  
А второй класс, собственно `PathFinder`, строит путь между `start` и `end`.

- В этом классе публичным должен быть только один метод `findPath(...)`. Сейчас несколько публичных методов и правила пользования поиском становятся излишне сложными.
Фактически, сейчас есть два вида поиска: "дальний поиск" `findPath(...)` и ближний поиск
```
public <T extends Entity> Position findNearestEntity(Position start, Class<T> targetType) {...}
```
В этом нет необходмости, достаточно оставить публичным только `findPath(...)`. И пусть он сначала вызывает "ближний поиск" и если найдет цель, то вернет List из одной позиции. 
А если не найдет ближним поиском, то запустит поиск дальний.

**10. abstract class Entity**

- Нарушение SRP, зависимость модели от представления- существо хранит спрайт с собственным изображением
```
public String getEmoji() {
  return emoji;
}
```
Модель(а это модель) не должна зависеть от представления и знать, как ее будут показывать юзеру.
Потому что в разных средах(консоль, Swing, Android) одна и та же модель может быть показана разными способами.
Спрайты всех существ должны храниться в классе, который распечатывает карту.

**11. public class Grass extends Entity**

- Нарушение Low Coupling. Этот класс, так же как и все прочие наследники Entity имеет ненужную зависимость на константный класс
```
public class Grass extends Entity {
  public Grass() {
    super(Constants.GRASS);
  }
}
```

Павильный подход- хранить спрайты в классе, который распечатывает карту.
Неправильный подход, который при этом не нарушает LC- хранить спрайт в себе, а не в константах
```
public class Grass extends Entity {
  private static final String SPRITE = "\uD83C\uDF40";

  public Grass() {
    super(SPRITE);
  }
}
```

**12. abstract class Creature extends Entity**

- Нарушение SRP, чужая ответственность, зависимость модели от представления.
Модель(а это модель) не должна ничего печатать в консоль.
```
System.out.printf(Constants.MOVE_LOG, this.getClass().getSimpleName(), currentPos, nextStep);
```
Иначе модель перестает быть универсальной и становится заточенной под конкретную среду и конкретное представление себя в этой среде- в данном случае, консоль.

В других средах(напр. Андроид) модель нельзя будет использовать. 
Другое представление для модели(напр. если одну и ту же модель нужно в программе показвать по-разному) нельзя будет сделать, или придется делать через костыль.

Если модель должна что-то сообщить миру, она может это сделать через паттерн CallBack: https://t.me/zhukovsd_it_chat/53243/139594

**13. class TurnActions extends Action**

- Нарушение SRP, несколько ответственностей в одном классе: сделать ход и возобновить ресурсы на карте.  
Класс нужно разделить на несколько. Имеется ввиду, что будет не один класс `TurnActions`, в котором будет делаться все то, что нужно сделать за ход.  
А будет группа классов, например в виде списка `List<Action> turnActions`, где каждый из Action'ов будет вызываться во время совершения хода
```
interface Action{
 void execute(Карта карта);
}

class ХодитьAction реализует Action {
  void execute(Карта карта) {
    //обойти всю карту
    //найти каждую креатуру
    //и дать ей пинка чтоб побежала
  }
}

class ДатьСигаретуВсемЗайцамAction реализует Action {
  void execute(Карта карта) {
    //обойти всю карту
    //найти всех зайцев и дать им по сигарете 
  }
}

List<Action> turnActions  = List.of{new ДатьСигаретуВсемЗайцамAction(), new ХодитьAction()};
for(Action a: turnActions ) {
  a.execute(карта);
}

/*
Результат: программа обойдет всю карту, найдет всех креатур и даст им пинка, чтобы они побежали.
А каждому зайцу предварительно даст сигарету.
*/
```

- Не должно быть этой проверки null. Метод `worldMap.getPositionOf(...)` должен бросать исключение, если пытаются получить координаты существа, которого нет
```
private void moveCreatures() {
  List<Creature> creatures = worldMap.getAllCreatures();
  for (Creature creature : creatures) {
    Position currentPos = worldMap.getPositionOf(creature);
    if (currentPos == null) {  // УБРАТЬ (прим. ред.)
      continue;
    }
    creature.makeMove(worldMap, pathFinder);
  }
}
```

- Зависимость модели(а это модель) от представления
```
System.out.printf(Constants.SPAWN_ENTITY, Grass.class.getSimpleName(), newPos);
```

**14. class WorldMapFactory**, простая фабрика Карты

+ (+)Фабрика карты, которая создает карту и заселяет ее существами, это хорошо.

- В проекте должна быть или фабрика карты или Action, который делает первоначальное заселение карты существами(здесь это класс InitActions).
В первом случае Фабрика создает карту и заселяет ее существами, а потом эта карта инжектится в конструктор Симуляции.
Во втором случае соответствующий Action вместе с другими потенциальными initAction'ами вызывается в самом классе Симуляция на старте и заселяет карту существами.
Существование и того и другого сразу- дискуссионно. Здесь класс InitActions не используется так, как это было задумано для initActions- не вызывается в классе Симуляции на старте. 
Я бы перенес методы из InitActions в фабрику, а сам класс InitActions удалил.  

**15. class WorldMapPrintTool**, распечатка карты

- Должен содержать в себе спрайты существ, а не брать их из самих существ.

**16. class Main**, содержит точку входа main

+ (+)Только создает и запускает Симуляцию, это хорошо.

- Магические числа: 5, 2, 1, 3. 

## ВЫВОД

Разобраться с Action'ами.  
Для лучшего понимания декомпозиции посмотреть ролики Сергея про шахматы. Посмотреть ролики Немчинского про SOLID- по одному ролику на каждую букву. 

n.55(126)  
#ревью #симуляция