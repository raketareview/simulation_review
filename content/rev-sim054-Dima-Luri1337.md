https://github.com/Luri1337/SimulationGame  
[Dima]

Программа работает, в остальном удручающе.

## НЕДОСТАТКИ РЕАЛИЗАЦИИ

1. Можно сделать паузу. Но пользователь программы этого никогда не узнает, потому что эта информация не выводится в консоль.  
Об этой фиче я сам узнал только из кода. 

## ХОРОШО

1. Спрайты хранятся не в самих существах

## ЗАМЕЧАНИЯ

1. Нейминг

- Название должно как можно лучше объяснять суть явления. В данном случа метод не сдвигает координаты, а складывает их
```
public Coordinates shift(CoordinatesShift shift) {
  return new Coordinates(x + shift.xShift, y + shift.yShift);
}

//ПРАВИЛЬНО:
public Coordinates add(CoordinatesShift shift) {...}
```

- В названии переменных не пиши тип данных, к которым они относится. И вообще не употребляй венгерскую ноттацию
```
HashMap<Coordinates, Entity> map = new HashMap<>();

//ПРАВИЛЬНО:
HashMap<Coordinates, Entity> entities = new HashMap<>(); //или coordinatesWithEntities
```

*Oracle Java code conventions, part."Naming conventions"*  
*Мартин, "Чистый код", гл.2*  

**2. Нарушение конвенции кода.** В любой ситуации выделяй тело блока скобочками. Исключение- метод equals()
```
if ((newX < 1) || (newX > 10)) return false;
if ((newY < 1) || (newY > 10)) return false;

//ПРАВИЛЬНО:
if ((newX < 1) || (newX > 10)) {
  return false;
}  
if ((newY < 1) || (newY > 10)) {
  return false;
}  
```

**3. Используй классы через их интерфейсы**
```
HashMap<Coordinates, Entity> map = new HashMap<>();

//ПРАВИЛЬНО:
Map<Coordinates, Entity> map = new HashMap<>();
```

**4. class Coordinates**

- При прочих равных используй примитивные типы, а не классы обертки
```
public Coordinates(Integer x, Integer y)

//ПРАВИЛЬНО:
public Coordinates(int x, int y)
```
Для использования обертки должна быть причина и выгода, которую дает применение этой обертки.
Тут выгоды никакой нет, но возможны баги
```
Coordinates coordinates = new Coordinates(null, null);
```

- Нарушение SRP. Координата не должна определять "возможность сделать сдвиг" координат
```
public boolean canShift(CoordinatesShift shift) {
  int newX = x + shift.xShift;
  int newY = y + shift.yShift;

  if ((newX < 1) || (newX > 10)) return false;
  if ((newY < 1) || (newY > 10)) return false;

  return true;
}
``` 
Координата не должна знать про проблемы Карты и даже про само существование карты. Координата должна просто хранить адрес в виде пары чисел x и y. 
В данном случае Координата не является универсальным классом, она неявно привязана в классу Карта потому что знает о конкретных границах этой Карты: 1, 1, 10, 10.
Поэтому Координату в этой редакции нельзя будет использовать в других аналогичных проектах- шахматах, крестиках-ноликах, похождениях дровосека Боба и других. 
Потому что во всех этих проектах у игровых досок будут другие размеры.

- Нарушение DRY. Значения размеров Карты дублируются в нескольких классах, а не находятся только в карте. В данном случае в Координате размеры карты захардкодены в `canShift(...)`

-Стандартные переопределения типа `equals()` и `hashCode()` должны располагаться в самом низу кода.

**5. class CoordinatesShif**

- В существовании этого класса нет смысла, его прекрасно может заменить class Coordinates. Например так
```
Coordinates shiftCoordinatesRight = new Coordinates(1, 0);
Coordinates shiftCoordinatesLeftDown = new Coordinates(-1, -1);
// и т.д.
```

**6. class GameMap**

- Карта содержит в себе фиксированные размеры, поэтому становится не универсальной
```
private static final int MAP_WIDTH = 10;
private static final int MAP_HEIGHT = 10;
```
Фиксированные размеры могут быть у шахматной доски(8x8) или игры крестики-нолики(3x3). 
Здесь размеры должны приниматься в конструктор.

- Как-то странно, что в Доске координаты начинаются с (1,1) 
```
for (int x = 1; x <= MAP_WIDTH; x++) {
  for (int y = 1; y <= MAP_HEIGHT; y++) {...}
}
```

Цитирую википедию:
```
В декартовой системе координат, начало координат — это точка, в которой пересекаются все оси координат. 
Это означает, что все координаты этой точки равны нулю. 
Например, на плоскости она имеет координаты (0,0)
```

- Нарушение инкапсуляции, класс предоставляет клиентскому коду подробности внутреннего устройства и доступ к нему
```
private final HashMap<Coordinates, Entity> map = new HashMap<>();

public HashMap<Coordinates, Entity> getMap() {
  return map;
}
```
В данный момент клиентский код может выполнять любые операции с HashMap Карты напрямую, игнорируя допустимые картой способы. 
Например так
```
Карта карта = new Карта(100, 100);
//заселить карту существами
карта.getMap.clear(); //геноцид минуя дозволенные картой механизмы
```
Из-за этого класс является гибридом со всеми вытекающими последствиями: *"Чистый код", гл.6* 

- При добавлении существа в карту, не проверяет координату на корректность. 
И зачем ты передаешь во входящие аргументы `Coordinates coordinates`, если в теле метода ты это не используешь, а берешь координату из entity?
```
public void setEntity(Entity entity, Coordinates coordinates) {
  entity.coordinates = coordinates;
  map.put(coordinates, entity);
}
```

- Никогда не возвращай null
```
private final HashMap<Coordinates, Entity> map = new HashMap<>();

public Entity getEntity(Coordinates coordinates) {
  return map.get(coordinates);  //может вернуть null
}
```
Возврат null повышает риск возникновения NullPointerException в программе

*Мартин, "Чистый код", гл.7.7-8*  
*Ютуб, Немчинский "Почему нельзя возвращать NULL?"*  

- При всех операциях с участием координаты(добавить, выдать, удалить и т.д.), нужно проверять координату на корректность. 
Если координата некорректна(находится вне пределов карты), нужно бросать исключение.

- Нарушение SRP, божественный класс, методы чужих ответственностей. 
Карта должна только хранить существа и обеспечить базовые операции с ними- вставить, выдать одно существо и список всех хранимых существ, удалить.
Если какой-то метод не нужен для обеспечения этого функционала, значит он не принадлежит к ответственности карты, а принадлежит к чужой ответственности.

Здесь методы чужих ответственностей: начальное заселение себя существами, определение темной(dark) клетки(что бы это ни значило), заполнение карты пустыми клетками, генерирование еды и т.д. 
Методы чужих ответственностей должны находиться в тех классах, в интересах которых они работают.
Если один и тот же метод используют разные классы, то метод нужно вынести в отдельный класс, например, BoardUtils.

- Метод совершения хода в карте- нарушение SRP.
Теперь можно вызвать из карты метод хода и телепортировать зайца из одного края в другой минуя все правила игровой логистики
```
Карта карта = new Карта(100, 100);
Координата координата = new Coordinates(1, 1);
карта.putEntity(координата, new Заяц());
карта.moveEntity(координата, new Coordinates(99, 99));

/* class GameMap */
  public void moveEntity(Coordinates from, Coordinates to) {
    Creature entity = (Creature) getEntity(from);

    if (entity.getAvailableMoves(this).contains(to)) {
      removeEntity(from);
      setEntity(entity, to);
      entity.hasMoved = true;
    }
  }
```
Должна ли карта учитывать логистику зайцев? Если да, то как? Единственно правильный ответ- карта вообще не должна иметь в себе метод телепортации.

- Карта не должна заполнять себя "Пустыми ячейками". Иначе теряется все преимущество, которое дает HashMap для хранения сущностей
```
private void fillMapWithEmptyCells() {
  for (int x = 1; x <= MAP_WIDTH; x++) {
    for (int y = 1; y <= MAP_HEIGHT; y++) {
      setEntity(new EmptyCell(new Coordinates(x, y)), new Coordinates(x, y));
    }
  }
}
```

Фактически, тут HashMap становится аналогом обычного массива, только хуже, бесполезно забивая память.
Например, есть игровая доска 100*100 и в ней единомоментно находится общим числом 150 разных существ: камней, травы, зайцев и т.д.  
Тогда при нормальном хранении этих данных в мапе с помощью ключ-значение, потребуется 150 записей.
Если в этой же мапе кроме этих значимых данных хранить еще пустые сущности, то потребуется уже 10.000 записей.  
Для определения того, что в точке карты никого нет, достаточно ввести метод 
```
private boolean isПустаяЯчейка(Координата координата) {...}
```

Карта должна работать со всеми хранимыми существами одинаково и не работать как-то по-особому с конкретным классом представителей и не должна даже знать по именам наследников Entity
```
public List<Creature> getAllCreatures() {...}

//ПРАВИЛЬНО ТАК:
public List<Entity> getEntities() //и тогда пусть клиент отбирает отсюда креатур

//ИЛИ ТАК:
public List<? extends Entity> getAllBy(Class<? extends Entity> clazz)  //но мне это меньше нравится 
```

**7. class BFS**, поиск пути

- Нарушение SRP. Класс должен просто искать путь от точки старта до точки, соответствующей заданным условиям. 
В данном случае- до точки, в которой находится существо нужного класса.
Эти условия класс должен принимать в себя и не определять эти условия самостоятельно
```
public List<Coordinates> findShortestPathForEntity(GameMap map, Coordinates start) 

//ПРАВИЛЬНО:
public List<Coordinates> findShortestPathForEntity(GameMap map, Coordinates start, Class<& extends Entity> target) 
```

Здесь поиск берет на себя часть чужой ответственности тем, что сам решает, чем будет питаться существо
```
if (startEntity instanceof Predator && targetEntity instanceof Herbivore) {
  return true;
}

if (startEntity instanceof Herbivore && targetEntity instanceof Grass) {
  return true;
}
```
Никто не может решать за существо, чем оно должно питаться. Гастрономические предпочтения Креатур должны храниться в самих Креатурах.

**8. public class Actions**

- Идея Actions здесь не осмыслена. Идея состоит в том, что нужно создать семейство родственных классов, объединенных общим интерфейсом.
Каждый из этих классов должен делать что-то свое с картой: одна акция должна заселять карту существами, другая делать ходы и т.д.
Actions, изложенный в ТЗ, это вариант реализации паттерна Command.
Сейчас Actions у тебя это просто сборник глобальных функций, сделанный в стиле процедурного программирования
```
public class Actions {

  public static void turnAction(GameMap map, BFS bfs) throws InterruptedException {...}

  public static void moveCreature(Creature creature, GameMap map, BFS bfs) {...}
}
```

Смысл Action'ов состоит в том, что должен быть общий класс/интерфейс Action и его наследники. 
Это своего рода вариация паттерна Command.
Т.е. акции должны быть родственны и одинаково использоваться через полиморфизм. Примерно так
```
interface Action{
 void execute(Карта карта);
}

class ХодитьAction реализует Action {
  void execute(Карта карта) {
    //обойти всю карту
    //найти каждую креатуру
    //и дать ей пинка чтоб побежала
  }
}

class ДатьСигаретуВсемЗайцамAction реализует Action {
  void execute(Карта карта) {
    //обойти всю карту
    //найти всех зайцев и дать им по сигарете 
  }
}

List<Action> actions = List.of{new ДатьСигаретуВсемЗайцамAction(), new ХодитьAction()};
for(Action a: actions) {
  a.execute(карта);
}

/*
Результат: программа обойдет всю карту, найдет всех креатур и даст им пинка, чтобы они побежали.
А каждому зайцу предварительно даст сигарету.
*/
```

**9. abstract class Entity**

- Содержит координату. Но координата нужна только тому существу, которое ходит. Поэтому entities должен хранить координату только начиная с уровня Creature.

- Содержит жизни: `int hp`. Но жизни нужны только тому существу, котороое может умереть(которое могут съесть). Поэтому hp должны хранить только те, кого могут съесть- Creature и, возможно, Трава.

- Нарушение инкапсуляции, эти поля не должны быть публичными или дефолтными
```
public Coordinates coordinates;
int hp;
```

- При такой реализации перегруженных конструкторов некоторые ентити при создании будут иметь координаты, а другие будут хранить null в Координате
```
public abstract class Entity {
  public Coordinates coordinates;
  
  public Entity(Coordinates coordinates) {
    this.coordinates = coordinates;
  }

  public Entity() {
  }
  //...
}  
```
Хранение null в полях класса не должно быть практикой при использовании классов.

**10. abstract class Creature extends Entity**

- Традиционное для проекта нарушение инкапсуляции
```
public boolean hasMoved;
public Coordinates nextMove;
```

- Последствия неправильной иерархии наследования.  
Из-за того, что в Entity хранится все, что может понадобиться потомкам и все, что не может им понадобиться, потомки часть полей инжектят в конструктор предка, а часть просто устанавливают
```
public abstract class Entity {
  public Coordinates coordinates;
  int hp;

  public Entity(Coordinates coordinates) {
    this.coordinates = coordinates;
  }
  //... 
}  

public Creature(Coordinates coordinates, int hp) {
  super(coordinates);
  this.hp = hp;
  hasMoved = false;
}
```

**11. class Herbivore extends Creature**

- Магические цифры: 25, 100.

- Нарушение SRP, при съедении еды, генерирует новую еду на карте
```
@Override
public Creature eat(GameMap map) {
  if (canEat(entity)) {
      //...
      map.generateNewFood();
  }
  //...
}
```
Это не ответственность Травоядного, это ответственность игровой логики в целом.   
Если нужно время от времени возобновлять ресурсы на карте, это должен делать отдельный класс.
В данном случае- специальный Action, который после каждой итерации ходов будет проверять наличие ресурсов на карте и возобновлять их в случае потребности. 

**12. class Predator extends Creature**

- Те же замечания, что у Травоядного.

**13. class EmptyCell extends Entity**

- Класс, которого не должно быть.  
Во-первых, Карта не должна хранить сущность "Пустая ячейка", о чем я писал выше.  
Во-вторых, Пустота не может быть наследником Существа, потому что существо существует, а пустота нет.

**14. class MapConsoleRenderer**

+ (+)В случае распечатки неизвестного существа метод `String getPieceSprite(Entity entity)` бросает исключение, это хорошо.

- Нарушение DRY. Еще один класс, который хранит в себе значение размеров Карты, а не берет размеры из самой карты: 1, 1, 10, 10.

- Если в цикле складываешь строки, используй StringBuilder, это менее затратно с точки зрения ресурсов
```
line += getSpriteForEmptySquare(new Coordinates(x, y));

//ПРАВИЛЬНО:
StringBuilder line = new StringBuilder();
for (int x = 1; x <= 10; x++) {
  if (map.isSquareEmpty(new Coordinates(x, y))) {
    line.append(getSpriteForEmptySquare(new Coordinates(x, y)));
    //...
  }
  line.append(RESET);
  System.out.println(line);
}
```

**15. class Simulation**

- Нарушение инкапсуляции- все методы публичные. Публичным должен быть только `void start()`

-Метод, который вообще не используется в программе: `GameMap getMap()`. Любой неиспользуемый код по определению мусор.

**16. class Main**, содержит точку входа main

+ (+)Только создает и запускает Симуляцию, это хорошо. Кажется, единственный класс, к которому нет претензий.

## АРХИТЕКТУРА

Реализация показывает отсутствие понимания ООП на базовом уровне: что такое наследование и как его нужно использовать. 
Отсутсвует понимание декомпозиции- того, как делить программу на классы в ООП стиле.

- Класс Карта собрал в себе все худшие практики.  
Пока нет знаний о SRP и правильном распределением ответственностей, сделай и используй доску только с такими методами
```
public class Board {
  private final Map<Coordinates, Entity> entities = new HashMap<>();
  //...

  public Board(int rows, int columns) {
    //...
  }

  public int getRows();    //кол-во строк (y)
  public int getColumns(); // кол-во столбцов (x)
  public void put(Coordinate coordinate, Entity entity);
  public Entity get(Coordinate coordinate);
  public Entity remove(Coordinate coordinate);
  public List<Entity> getAll();

  public Coordinate getCoordinate(Entity entity);

  public boolean isEmpty(Coordinate coordinate);  //пустая ячейка
  public boolean isValid(Coordinate coordinate); //проверка на то что координата находится в пределах доски
}
```

- Actions сделаны не по ТЗ. Непонимание идей иерархии классов, наследования и полиморфизма.

- Entity сделаны в процедурном стиле- поля всех наследников находятся на базовом уровне, непонимание идей иерархии классов и наследования.  
В иерархии классов поля должны появляться на том уровне, где они будут использоваться. Например
```
абстрактный класс Существо {
}

класс Трава наследует Существо {
}

абстрактный класс Креатура наследует Существо {
  private final int скорость;

  public Креатура(int скорость) {
    this.скорость = скорость;
  }
  
  public int getСкорость() {
    return скорость;
  }
}

класс Бегемот наследует Креатура {
  private final static int СКОРОСТЬ = 3;
  private final static int ГЛУБИНА_НЫРЯНИЯ = 7;

  private final int глубинаНыряния;

  public Бегемот() {
    super(СКОРОСТЬ);
    this.глубинаНыряния = ГЛУБИНА_НЫРЯНИЯ;
  }
  
  public int getГлубинаНыряния() {
    return глубинаНыряния;
  }
}
```

- Другие плохие практики в проекте: 
  - Дублирование кода, как минимум три класса независимо друг от друга содержат в себе размеры Карты.
  - Нарушение инкапсуляции, публичные поля у классов, которые не должны быть публичными.

## ВЫВОД

Для изучеия декомпозиции посмотреть ролики Сергея про шахматы. Посмотреть ролики немчинского про DRY, инкапсуляцию, наследование, полиморфизм, SRP.

n.54(123)  
#ревью #симуляция